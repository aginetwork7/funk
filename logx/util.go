package logx

import (
	"encoding"
	"fmt"
	"path"
	"runtime"
	"strconv"
	"strings"
)

func flatten(kvs ...interface{}) string {
	if len(kvs) == 0 {
		return ""
	}

	var b strings.Builder
	for i := 0; i < len(kvs); i += 2 {
		if i > 0 {
			b.WriteRune(' ')
		}

		k := kvs[i]
		var v interface{}
		if i+1 < len(kvs) {
			v = kvs[i+1]
		} else {
			v = ""
		}
		b.WriteString(key(stringify(k)))
		b.WriteRune('=')
		b.WriteString(stringify(v))
	}

	return b.String()
}

func key(s string) string {
	switch s {
	case "error":
		return colorRed + s + colorDefault
	case "logger", "caller":
		return colorBlue + s + colorDefault
	default:
		return colorYellow + s + colorDefault
	}
}

func quote(s string) string {
	if strings.ContainsAny(s, " ") {
		return fmt.Sprintf("%q", s)
	}
	return s
}

const (
	colorDefault = "\x1b[0m"
	colorRed     = "\x1b[1;31m"
	colorGreen   = "\x1b[1;32m"
	colorYellow  = "\x1b[1;33m"
	colorBlue    = "\x1b[1;34m"
)

func stringify(v interface{}) string {
	var s string
	switch vv := v.(type) {
	case string:
		s = vv
	case fmt.Stringer:
		s = vv.String()
	case error:
		s = vv.Error()
	case nil:
		return "null"
	case []byte:
		return string(vv)
	case encoding.TextMarshaler:
		vb, err := vv.MarshalText()
		if err != nil {
			return err.Error()
		}
		return string(vb)
	default:
		s = fmt.Sprint(v)
	}

	return quote(s)
}

func caller(skip int) string {
	for i := 1; i < 3; i++ {
		_, file, line, ok := runtime.Caller(skip)
		if ok && file != "<autogenerated>" {
			return path.Base(file) + ":" + strconv.Itoa(line)
		}
	}
	return "unknown"
}
